from typing import AbstractSet
from typing import Callable
from typing import Mapping
from typing import Optional
from typing import Sequence
from typing import Union
from typing import overload

class ClassWithMovableField:
    def __init__(self) -> None: ...

    @property
    def movable(self) -> list[test_stl_ext.Movable]: ...

    @movable.setter
    def movable(self, arg: Sequence[test_stl_ext.Movable], /) -> None: ...

class Copyable:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg: int, /) -> None: ...

    @property
    def value(self) -> int: ...

    @value.setter
    def value(self, arg: int, /) -> None: ...

class FuncWrapper:
    def __init__(self) -> None: ...

    @property
    def f(self) -> Callable[[], None]: ...

    @f.setter
    def f(self, arg: Callable[[], None], /) -> None: ...

    alive: int = ...
    """static read-only property"""

class Movable:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg: int, /) -> None: ...

    @property
    def value(self) -> int: ...

    @value.setter
    def value(self, arg: int, /) -> None: ...

class NonAssignable:
    def __init__(self) -> None: ...

    @property
    def value(self) -> int: ...

    @value.setter
    def value(self, arg: int, /) -> None: ...

class StructWithReadonlyMap:
    def __init__(self) -> None: ...

    @property
    def map(self) -> dict[str, int]: ...

def array_in(arg: Sequence[int], /) -> int: ...

def array_out() -> list[int]: ...

def call_function(arg0: Callable[[int], int], arg1: int, /) -> int: ...

def complex_array_double(arg: Sequence[complex], /) -> list[complex]: ...

def complex_array_float(arg: Sequence[complex], /) -> list[complex]: ...

def complex_value_double(arg: complex, /) -> complex: ...

def complex_value_float(arg: complex, /) -> complex: ...

def copyable_in_lvalue_ref(arg: test_stl_ext.Copyable, /) -> None: ...

def copyable_in_ptr(arg: test_stl_ext.Copyable, /) -> None: ...

def copyable_in_rvalue_ref(arg: test_stl_ext.Copyable, /) -> None: ...

def copyable_in_value(arg: test_stl_ext.Copyable, /) -> None: ...

def empty_tuple(arg: tuple[], /) -> tuple[]: ...

def flip_vector_bool(arg: Sequence[bool], /) -> list[bool]: ...

class float_vec:
    def __init__(self) -> None: ...

    def push_back(self, arg: float, /) -> None: ...

    def size(self) -> int: ...

def identity_list(arg: Sequence[int], /) -> list[int]: ...

def identity_string(arg: str, /) -> str: ...

def identity_string_view(arg: str, /) -> str: ...

def map_copyable_in_value(x: Mapping[str, test_stl_ext.Copyable]) -> None: ...

def map_movable_in_lvalue_ref(x: Mapping[str, test_stl_ext.Movable]) -> None: ...

def map_movable_in_ptr(x: Mapping[str, test_stl_ext.Movable]) -> None: ...

def map_movable_in_rvalue_ref(x: Mapping[str, test_stl_ext.Movable]) -> None: ...

def map_movable_in_value(x: Mapping[str, test_stl_ext.Movable]) -> None: ...

def map_return_copyable_value() -> dict[str, test_stl_ext.Copyable]: ...

def map_return_movable_value() -> dict[str, test_stl_ext.Movable]: ...

def map_return_readonly_value() -> test_stl_ext.StructWithReadonlyMap: ...

def movable_in_lvalue_ref(arg: test_stl_ext.Movable, /) -> None: ...

def movable_in_ptr(arg: test_stl_ext.Movable, /) -> None: ...

def movable_in_rvalue_ref(arg: test_stl_ext.Movable, /) -> None: ...

def movable_in_value(arg: test_stl_ext.Movable, /) -> None: ...

def optional_copyable(x: Optional[test_stl_ext.Copyable]) -> None: ...

def optional_copyable_ptr(x: Optional[test_stl_ext.Copyable]) -> None: ...

def optional_non_assignable(arg: test_stl_ext.NonAssignable, /) -> Optional[test_stl_ext.NonAssignable]: ...

def optional_none(x: Optional[test_stl_ext.Copyable]) -> None: ...

def optional_ret_opt_movable() -> Optional[test_stl_ext.Movable]: ...

def optional_ret_opt_movable_ptr() -> Optional[test_stl_ext.Movable]: ...

def optional_ret_opt_none() -> Optional[test_stl_ext.Movable]: ...

def optional_unbound_type(x: Optional[int] = None) -> Optional[int]: ...

def optional_unbound_type_with_nullopt_as_default(x: Optional[int] = None) -> Optional[int]: ...

def parent_path(arg: os.PathLike, /) -> os.PathLike: ...

def replace_extension(arg0: os.PathLike, arg1: str, /) -> os.PathLike: ...

def reset() -> None: ...

def return_copyable() -> test_stl_ext.Copyable: ...

def return_copyable_ptr() -> test_stl_ext.Copyable: ...

def return_empty_function() -> Callable[[int], int]: ...

def return_function() -> Callable[[int], int]: ...

def return_movable() -> test_stl_ext.Movable: ...

def return_movable_ptr() -> test_stl_ext.Movable: ...

def return_void_function(arg: Callable[[], None], /) -> Callable[[], None]: ...

def set_in_lvalue_ref(x: AbstractSet[str]) -> None: ...

def set_in_rvalue_ref(x: AbstractSet[str]) -> None: ...

def set_in_value(x: AbstractSet[str]) -> None: ...

def set_return_value() -> set[str]: ...

def stats() -> dict: ...

def swap_pair(arg: tuple[int, float], /) -> tuple[float, int]: ...

def swap_tuple(arg: tuple[int, float], /) -> tuple[float, int]: ...

def tuple_movable_in_lvalue_ref(arg: tuple[test_stl_ext.Movable], /) -> None: ...

def tuple_movable_in_lvalue_ref_2(arg: tuple[test_stl_ext.Movable], /) -> None: ...

def tuple_movable_in_ptr(arg: tuple[test_stl_ext.Movable], /) -> None: ...

def tuple_movable_in_rvalue_ref(arg: tuple[test_stl_ext.Movable], /) -> None: ...

def tuple_movable_in_rvalue_ref_2(arg: tuple[test_stl_ext.Movable], /) -> None: ...

def tuple_movable_in_value(arg: tuple[test_stl_ext.Movable], /) -> None: ...

def tuple_return_movable() -> tuple[test_stl_ext.Movable]: ...

def tuple_return_movable_ptr() -> tuple[test_stl_ext.Movable]: ...

def unordered_set_in_value(x: AbstractSet[str]) -> None: ...

def unordered_set_return_value() -> set[str]: ...

def variant_copyable(arg: Union[test_stl_ext.Copyable, int], /) -> None: ...

def variant_copyable_none(x: Optional[Union[int, test_stl_ext.Copyable]]) -> None: ...

def variant_copyable_ptr(arg: Union[test_stl_ext.Copyable, int], /) -> None: ...

def variant_copyable_ptr_none(x: Optional[Union[test_stl_ext.Copyable, int]]) -> None: ...

def variant_ret_var_copyable() -> Union[test_stl_ext.Copyable, int]: ...

def variant_ret_var_none() -> Union[None, test_stl_ext.Copyable, int]: ...

def variant_unbound_type(x: Optional[Union[list, tuple, int]] = None) -> Union[None, list, tuple, int]: ...

def vec_copyable_in_value(arg: Sequence[test_stl_ext.Copyable], /) -> None: ...

def vec_movable_in_lvalue_ref(arg: Sequence[test_stl_ext.Movable], /) -> None: ...

def vec_movable_in_ptr_2(arg: Sequence[test_stl_ext.Movable], /) -> None: ...

def vec_movable_in_rvalue_ref(arg: Sequence[test_stl_ext.Movable], /) -> None: ...

def vec_movable_in_value(arg: Sequence[test_stl_ext.Movable], /) -> None: ...

def vec_return_copyable() -> list[test_stl_ext.Copyable]: ...

def vec_return_movable() -> list[test_stl_ext.Movable]: ...

@overload
def vector_str(arg: Sequence[str], /) -> list[str]: ...

@overload
def vector_str(arg: str, /) -> str: ...

del Sequence
del overload
del Callable
del Mapping
del Optional
del AbstractSet
del Union